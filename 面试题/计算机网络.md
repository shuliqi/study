

## 1.计算机的层次协议

 ***七层协议***：（应用层， 表示层， 会话层），运输层，网络层，数据链路层， 物理层。

 ***五层协议***：应用层， 传输层， 网络层，（数据链路层， 物理层）。

***四层协议***：应用层， 传输层， 网络层， 网络接口层



![网络层次](https://img-blog.csdn.net/20161116144744393)

## 2.UDP（用户数据报）协议的特点

1.UDP 是面向无连接的。 在发送数据之前是不需要建立连接的。当然在发送数据结束之后也不需要释放连接。

2.UDP 是尽最大努力交付， 也就是说不保证可靠交付。

3.UDP 是面向报文的。因为UDP对于应用层交互下来的数据， 不拆分， 也不合并， 只是加一个首部就直接交给网络层了。应用层给了它多长的报文， 它就照样发送， 一次发送一个报文。接收方收到它的数据之后， 只需要去除首部就可以了,造成的影响就是应用层要控制报文的大小。如果报文太长， 网络层就西需要切片， 分组等等降低效率。如果太短的话， 会使IP 太小。

4.UDP 可以提供 一对一， 一对多， 多对多，多对一的交互通信。

5.UDP 的首部开销小。只有8 个字节。



## 3. UDP（用户数据报协议）） 的首部格式：

1. 源端口：源端口号。在需要对方回信时选用，不需要时可用全0.

2. 目的端口：目的端口号。这在终点交付报文时必须要使用到。

3. 长度： UDP用户数据报的长度，其最小值是8（仅有首部

4. 检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃

![img](https://img-blog.csdn.net/20160318110857394)

## 4. TCP（传输控制协议）的特点：

1. 面向连接的。 发送数据之前需要三次握手，发送数据之后需要释放连接（四次挥手）
2. 一对一的通信交互
3. 提供可靠的交付
4. 提供全双工通信。 意思我在发送（接收）数据的同时也能接受（发送数据）数据。 因为TCP都设置有接收缓存和发送缓存。
5. 面向字节流。应用层和运输层的TCP的交互是每次一个字节。好处就是如果应用成给的报文太短的话， TCP 有缓冲，可以等待字节积累到一定的长度再发送， 如果报文太长， 可以切短在发送。





## 5.TCP报文的首部格式

#### ![image.png](https://segmentfault.com/img/bVbCsDx)

#### 源端口，目标端口

#### 序号：

tcp 传输的字节流中的每一个字节都要按顺序编号， 所有在tcp建立连接的时候就该确认初始编号。

所有首部的这个字段的意思： **本报文发送的的数据的第一个字节的序号**

#### 确认号

表示**希望收到对方下一个报文段的第一个数据字节的序号**

#### 控制位

* URG: URG=1 时， 表示紧急指针字段有效
* ACK：ACK = 1 时， 表示确认号有效， 否则无效。在建立连接后的所有传送的报文都必须把ACK=1
* PSH:PSH 设置为1 ， 并立即发送一个一个报文， 接收方收到PSH = 1的字段， 就会尽快的向前交互接受应用程序。而不是等到所有的缓存都填满了再向上交互。
* RST： 复位， RST = 1 时表示当前的TCP连接出现了严重的差错， 必须释放掉连接，然后再建立连接。
* SYN: SYN = 1 ACK = 0 表示这是一个请求建立连接的请求， 如果同意建立连接， 就应该使 SYN = 1 ACK = 1.因此SYN  是表示一个请求建立连接 或者是接受建立连接的字段。
* FIN：结束。， 用来释放一个连接。 FIN = 1 表示数据已经传输完毕，并且要求释放运输连接。

## 6.三次握手

假设客户端是主动打开，服务端是被动打开

##### 第一次握手：

CLOSE状态的客户端发送SYN=1(请求建立连接)， seq = x (虽然这时候不能携带数据，但是得消耗一个序号， x是一个随机数)  给客户端， 然后进入SYN-SENT（同步已经发送）状态。

##### 第二次握手：

被动打开的处于CLOSE状态服务器， 处于LISTEN状态， 接受到客户端的建立连接的请求， 如果是同意连接， 则向客户端发送SYN =1 (接受建立连接的请求) ACK = 1(确认号是有效的) seq = y （虽然不能携带数据，但是也消耗一个序号）ack =  x+ 1(确认号， 希望收到对方下一个数据第一个字节的序号)， 那然后进入SYN-RCED（同步已经收到）

##### 第三次握手：

客户端收到服务端的同意建立连接之后，发送seq = x + 1（自己消耗的序号）， ack = y + 1(确认号： 希望下次收到的对方的数据的第一个字节的序号)。ACK =1 (确认号是有效的)。然后自己进入（ESTABLISHED）--> 一建立连接状态

服务器收到确认之后， 也进入ESTABLISHED状态。然后两端就可以相互传输数据了。

图示如下：

![](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 7. 为什么还需要第三次确认呢？

这是为了**防止已经失效的建立连接的请求突然有传送到了服务器**

场景：A发送一个建立连接的请求之后，请求在网络中滞留了，但是A很久没有收到确认，于是又发了一次请求。 滞留的请求以延迟到连接释放之后的某个时间到到达B， 这本是一件失效的请求。 但是这时有传送到了B， 所以B 会认为这是A 又一次建立连接的请求。， 于是就向A 发送同意连接， 假如么有第三次握手， 只要B发送确认就建立连接。但是A 并没有发送建立连接的请求， 所以自然不会理B 的确认。但是B却意味新的连接已经建立， 一直在A 的发来的数据。这样就浪费了B 的很多资源。

## 8. 四次挥手

假设A主动要释放连接， B 被动释放连接

##### 第一次挥手：

当前处于ESTABLISHED(已建立连接)状态的A客户端向浏览器发送FIN = 1(请求释放连接)， seq = u（本报文发送的数据的第一个字节的序号， 这里应该是上一次发送的数据的最后一个字节的序号 + 1）， 然后A 进入 FIN-WAIT1状态

##### 第二次挥手：

处于ESTABLEISHED(已建立连接)状态的B 服务器接受到释放链接的请求， 然后给A 发送一个确认： ACK= 1（表示同意关闭）， seq = v(本报文发送的数据的第一个字节的序号， 这里应该是上一次发送的数据的最后一个字节的序号 + 1), ack = u + 1(确认号： 期望下次收到对方的数据的第一个字节的序号)。然后自己进入CLOSE-WAIT状态。这时候处于半关闭状态， A没有数据要再发送给B, 但是B 要发送数据给A， A 仍然要接收的。

A收到确认信息之后就进入 FIN-WAIT2状态。 等待B 发送释放链接的请求。

##### 第三次挥手：

B 如果没有数据要发送给A ， 则向A发送释放连接的请求， FIN = 1 (请求释放连接)。 ACK =1 ， seq = w（如果中间有传输数据， 就是传输数据的最后一个字节的序号 +1 ）, ack = u+ 1发送给A。 然后进入fIN-LAST状态

##### 第四次挥手： 

A 收到释放连接的请求之后，就给B 发送一个确认 ACK = 1, seq = u +1, ack = w +1。然后进入TIME-WAIT 状态， 等2MSL 时间之后， 就关闭连接。

B 收到A 的确认之后就关闭连接（CLOSE）

2MSL： 最长报文寿命（2 分钟）。 说明这里要等4 分钟。

图示：

![](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 9. 为什么要等2MSL

* 是为了A 的最后一次ACK 报文段能传到B

  如果A 发送的最后确认报文丢失了， 因此处在FIN-LAST状态的B 收不到确认报文， 所以会重发 请求释放联机的请求。 如果A 之前接受到请求就关闭的话， 那么就接受不到这个重发。B 也就收不到确认， 就无法进入CLOSE状态 

* 为了防止已失效的建立连接的请求出现在本连接中

  A 在发送最后一个确认的报文之后。在2MSL中，就可以让那个在本连接中所产生的所有的报文段从网络消失。这样就可以使下一个连接不会出现这种旧连接请求报文段。



## 10 http报文

### 1.http 请求报文：

![img](https://pics0.baidu.com/feed/241f95cad1c8a786c52cc827e35dba3b70cf506b.jpeg?token=b9b631c8d7c63b16481859f07e34c9a4)

#### 请求的方法

1. OPTION:  返回指定url资源所能够支持的http 请求的方式
2. GET： 用于向服务器请求指定URL 的资源，请求的参数是直接带在url上， 所以它是没有主体的。
3. HEAD:  跟GET 请求差不多，只是响应报文中没有没有传回这个资源
4. POST:  向指定URL的资源传递数据， 数据就是实体
5. PUT： 向指定URL上传数据，如果权限允许，该资源会被替换。
6. TRACH: 回显服务器收到的请求
7. CONNECT：用于代理用的。

#### 请求头

1. Host: host 是必须有的， 当前网站的域名
2. referer: 来源网站的地址
3. Accept: 客户端可接收数据的类型
4. cookie： 要发送给客户端的cooki
5. Catch-control:  表示当前请求的资源需要缓存
6. user-argent： 当前客户端浏览器的一些信息

#### 空格

请求头后面的是一个空行， 里面包含一个回车和一个换行符号。表示请求头字段已经结束

#### 实体

### 1.响应头报文

![img](https://pics0.baidu.com/feed/0dd7912397dda144fd417feb31e3a3a40df486fd.jpeg?token=045fea951b3b9365f16f9af449d34395)

#### 状态行

·	版本号， 状态码，状态短语 

​	 状态码：

​			1xxx: 表示通知信息， 表示请求已收到或者正在处理

​			 2xxx: 表示成功，如已经接收到了或者已经知道了

​			 3xx: 表示重定向，如果要完好吃呢个请求， 需要进一步的行动

​			 4xx: 表示客户端错误

​			5xx: 开头表示服务器错误

​			

​    301: 表示资源被永久放在别的位置上了

​	302: 表示资源临时被放在被的位置上了

​	303: 表示当前请求可以用另一个url 请求， 客户端使用get的方式重新去请求这个资源

​	304: 表示该资源和上次请求的没有改变， 可以继续使用缓存的资源

### 9 http1 和http2的区别

[http1 和 http 2的区别](https://zhuanlan.zhihu.com/p/102561034)

https://www.cnblogs.com/smlp/p/9779206.html

   



#### http1

* 队头阻塞 

  队头阻塞是指按顺序请求的序列， 其中某一个请求因为某种原因而被阻塞时， 那么其他的请求也一并被阻塞了。导致客户端迟迟没有收到响应

  解决： 减少http 请求

* 无状态特性

  纯净的http是不记住状态的。就像cookie。这就导致每一次请求都是新的连接。就会造成这样的一个状态。 我上一个请求明明是登陆了。但是下一个请求并不知道和上一个请求有啥关联

* 不安全

  http1传输的数据是不加密的。所有很有可能被中途劫持， 篡改。

#### http2

http2 并没有http1的语法， 只是在应用层的时候增加了二进制分帧的方式来传输。

* 多路复用

  也就是说在一个连接里面， 可以发多个请求。



https://vue3js.cn/interview/http/HTTP_HTTPS.html#%E4%B8%80%E3%80%81http
