# 1.浏览器缓存

[前端的缓存](https://shuliqi.github.io/2019/12/03/%E5%89%8D%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/)

#### 位置来分类

1. service work

2. Memory cache 

   存在内存上， 所以是短期的存储，浏览器关闭之后就会被清除

3. Disk catch（http Cache）

   存在硬盘上的， 是一个永久的存储。

   但是浏览器也会有一个神秘的算法去把最老的， 已经过时的来缓存清除掉

   

#### 按失效时间来分

#### 强缓存

优点： 减少请求次数。

##### 1.expires 

一个绝对的时间，当前的时间 + 要缓存的时间

##### 2. Cache-control

一个相对的时间， 相对于当前的时间，多少时间之后

* Max-age: 缓存的最大有限时间
* public: 所有的资源都可以缓存（客户端 和代理端都可以缓存）
* p rivate: 只有客户端可以缓存， 代理服务器不可以缓存
* no-store:  所有的内容都不不缓存
* no-cache： 虽然字面意思是不要缓存， 但是内容还是需要缓存的
* must-revalidate： 最大缓存时间到期后， 必须向后端发起请求

#### 对比缓存

强缓存没有命中的话， 那么就使用对比缓存

优点： 减少响应体的内容，来加快数据的网络传输

##### 1. Last-Modified/ if-Modified-since

服务端第一次响应， 响应头设置`last-modified`（文件最后修改的时间）

客户端第二次请求， 请求头设置`if-modified-since` --> 也就是上一次服务器返回的`last-modified`

如果时间相等， 所以文件没有被修改， 直接返回304 状态码，不发送结果。 浏览器使用缓存

##### 2. Etag/ if-none-match

对请求的内容进行加密成一个唯一的标识符，传给前端，服务器第二次对比，来看是否要发送请求体



## 2.浏览器的渲染原理

[浏览器的渲染原理](https://shuliqi.github.io/2018/03/24/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B/)

##### 1. 生成DOM树

因为浏览器不识html，所以需要把html转换成浏览器识别的数据结构---DOM树

##### 2. 生成CSSOM树

因为浏览器也不识别css,所以先把css 转换成浏览器识别的数据结构--stylesheet

然后根据DOM 树的节点的样式，生成CSSOM树

##### 3. 渲染树

DOM树和CSSOM树 结合生成渲染树（除去dispaly： none）的元素

然后进行计算布局

##### 4. 分成和绘制

将3d,透视变换的节点生成图层树。

然后进行 栅格化 ---> 合成---> 显示



#### 回流

如果元素的几何属性(尺寸属性),隐藏属性发生变化， 就会导致重新绘制，这个过程就是回流（布局-分层-绘制-图层-栅格化--合成-显示）

触发回流的属性

*  盒子属性： width， margin，padding，border
* 定位属性：float， position，top
* 文字属性：text-align，text-deraction，font

#### 重绘

当元素的外观属性发生变化，就会触发重绘。 重绘少了布局-分成阶段。 重绘不一定会触发回流， 但是回流一定会触发重绘。

触发重绘的属性：

* color， background, border-color

#### 避免回流和重绘

* 使用transform代替 top
* 使用opacity 代替visibility， dispaly: none
* 尽量少用table布局
* **尽可能在`DOM`树的最末端改变`class`**
* 避免使用多层内联样式
* **将动画效果应用到`position`属性为`absolute`或`fixed`的元素上**，
* **免使用`CSS`表达式**，可能会引发回流。



### 3. 输入url到页面渲染都发生了什么？

* DNS解析

  假设输入的是 www.baicu.com（www.baidu.com.）后面的。 是默认去掉了， 默认的就是根域名服务器

  输入url之后， 需要去找能提供资源的机器的ip，因为url不是ip. 所以第一步是DNS 解析。 首先在本地域名服务器查找ip， 如果没有找到， 则、向跟域名服务器（.）。 如果还没有找到， 本地域名服务器就向顶级（.com.）查找。如果就还是没找到，则继续向上一级域名服务器（baidu.com.）如果还没有就向www.baidu.com. 域名服务器查到，知道找到ip地址位置，本地域名服务器得到ip地址之后呢， 就把它缓存在本地（为了下一次不需要费那么大周折查找ip）.

  * DNS 解析的过程需要很多的请求（UDP 和 TCP）。 而且经历的过程非常的繁琐， 导致会消耗很多的时间。那有什么可以解决这问题吗？ 有， 那就是DNS 缓存

  * DNS 缓存：从浏距离浏览器最近的来划分： 浏览器缓存（在浏览器输入一个地址之后。 下次输入一部分，浏览器能提示全部 的）， 系统缓存（hosts），路由器缓存， IP域名服务器缓存，顶级域名服务器缓存， 主域名服务器缓存。

  * DNS 负载均衡

    DNS 查找会存在这样的问题，就是每一次查询的ip 是否都是相同的， 如果是相同的， 那么说明资源都是一台机器上， 那是什样的机器性能是支持那么大的请求量呢？ 明显这样是行不通的。所以公司一般会部署很多的机器。 用户发出请求之后（并不关心是哪台机器给他处理的， 只关心结果）。 所以可能会t提照离它最近的机器的ipd的机器的来处理请求（cdn）。这样就能做到负载均衡来

* TCP连接：三次握手

* 发送http请求

* 服务器处理请求，返回响应

* 浏览器渲染页面--- > 知识点

* 释放TCP连接：四次握手

