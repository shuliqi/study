

# 算法题



# 1. 判断是否是回文字符串

写一个函数，判断传入的字符串是否是回文字符串

> 回文字符串是指从左往右读和从右往左读都是一样的如： abcba，abccba

```javascript
// 使用api方式
function isPalindrome(str) {
  if (typeof str !== 'string') return;
  return str.split("").reverse().join("") === str;
}


// 递归方式
function isPalindrome (str) {
  if (typeof str !== 'string') return;
  let i = 0, j = str.length - 1;
  while(i < j) {
    if (str.charAt(i) === str.charAt(j)) {
      i++;
      j--;
    } else {
      return false
    }
  }
  return true;
}
console.log("11", isPalindrome('abccba')) // true
```



# 2. 无重复字符的最长子串

1. 题目

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



**解法:**

遍历字符串，判断字符是否在滑动窗口数组里

- 不在则 `push` 进数组
- 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 `push` 进数组
- 然后将 `max` 更新为当前最长子串的长度

遍历完，返回 `max` 即可

![img](https://user-gold-cdn.xitu.io/2020/4/25/171af6ebb321bef9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```javascript
function lengthOfLongest(str) {
  const subArr = [];
  let max = 0;
  for(let i = 0 ; i < str.length; i++ ) {
    const index = subArr.indexOf(str.charAt(i))

    if (index === -1) {
      subArr.push(str[i]);
      //  Math.max 返回一组数据中较大的值
      max = Math.max(subArr.length, max) 
    } else {
      subArr.splice(0, index)
    }
  }
  return max
}

console.log(lengthOfLongest('abcabcbb')); // 3
```

# 3. 最小栈

.**题目:**

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

**示例:**

```javascript
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

#### **解法：**

```javascript
// 最小栈
function MinStack() {
  this.items = [];
  this.min = null;
}
MinStack.prototype.push = function (x) {
  if (!this.min) this.min = x;
  this.min = Math.min(x, this.min)
  this.items.push(x);

}
MinStack.prototype.pop = function() {
  this.items.pop();
  this.min = Math.min(...this.items)
};
MinStack.prototype.top = function() {
  return this.items[this.items.length - 1];
}
MinStack.prototype.getMin = function() {
  return this.min;
}

const minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
console.log(minStack.getMin());   // --> 返回 -3.
minStack.pop();
console.log(minStack.top());      // --> 返回 0.
console.log(minStack.getMin());   // --> 返回 -2.
```





# 4.最长公共前缀





# 冒泡排序

`思想：`比较相临的两个数，大的数和小的数进行交换位置。

```javascript
{
    // 冒泡算法
    function bubbleSort(arr) {
        const len = arr.length;
        for(let i = len - 1; i > 0; i--) {
            for(let j = 1; j <= i; j++ ) {
                if (arr[j-1] > arr[j]) {
                    let temp = arr[j-1];
                    arr[j-1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
    return arr;
    }
    console.log(bubbleSort([4,1,8,3,2,8,11,0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231536252537446.png)





# 快速排序

`思想：` 选定一个数作为基准，小于这个基数放在一个S集合， 大于这个基数的放在另外一个B集合。这两个集合分别进行快速排序。 最后S集合，基数，B 集合进行合并。

```javascript
{
    // 快速排序
    function quickSort(arr) {
        if (arr.length <= 1) {
          
        } else {
            var leftArr = []; // 比基数小的集合
            var rightArr = []; // 比基数大的集合
            var base = arr[0]; // 基数
            for(let i = 1; i < arr.length; i++ ) { // 注意不能和基数混合 i是从1 开始的
                if (arr[i] < base) {
                    leftArr.push(arr[i]);
                } else {
                    rightArr.push(arr[i]);
                }
            }
        }
        return quickSort(leftArr).concat(base, quickSort(rightArr));
    }
    console.log(quickSort([4,1,8,3,2,9,11,0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231537564105629.jpg)







# 归并排序

采用分治的方式，将无序的数组拆分成N 部分，然后再合并

```javascript
{
    // 递归排序
    function mergeSort(arr) {
        if (arr.length <= 1) {
            return arr;
        } else {
            const mid = Math.ceil(arr.length * 0.5);
            const left = arr.slice(0, mid);
            const right = arr.slice(mid);
            return merge(mergeSort(left), mergeSort(right))
        }
    }
    function merge(left, right) {
        const result = [];
        while(left.length > 0 && right.length > 0) { // 注意这里是&&
            if (left[0] < right[0]) {
                result.push(left.shift());
            } else {
                result.push(right.shift());
            }
        }
        return result.concat(left, right);
    }
    console.log(mergeSort([4,1,8,3,2,9,11,0])); // [0, 1, 2, 3, 4, 8, 9, 11]
}
```

![clipboard.png](https://segmentfault.com/img/bVbc9vd?w=1014&h=855)



# 插入排序

`思想：`在已经排好序的序列上在插入一个数， 这个数与有序序列的数进行比较，放在合适的位置

```javascript
{
    // 插入排序
    function insertSort(a) {
        let len = a.length;
        for( let i = 1; i < len; i++) {
            let key = a[i];
            let j = i - 1;
            while( j >= 0) {
                if (a[j] > key) {
                    a[j+1] = a[j];
                } else {
                    break; // 结束循环
                }
                j--;
            }
            a[j + 1] = key;
        }
        return a;
    }
    console.log(insertSort([4,1,8,3,2,9,11,0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231533515818732.png)





# 选择排序

`思想:`每一次循环都找出最大的数或者最小的数；

```javascript

{
    // 选择排序
    function selectSort(a) {
        const len = a.length;
        for( let i = 0; i < len; i++ ) {
            let min = a[i];
            let index = i;
            for( let j = i + 1; j < len; j++ ) { // 注意： 是从i+1 开始的
                if (a[j] < min) {
                    min = a[j];
                    index = j;
                }
            }
            if (index !== i) {
                let temp = a[i];
                a[i] = min;
                a[index] =temp;
            }
        }
        return a;
    }
    console.log(selectSort([4,1,8,3,2,9,11,0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231538466606780.jpg)