# 算法题

# 1. [回文数](https://leetcode-cn.com/problems/palindrome-number/)

写一个函数，判断传入的字符串是否是回文字符串

> 回文字符串是指从左往右读和从右往左读都是一样的如： abcba，abccba

```javascript
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
    x = String(x);
    // 如果第一个字符不是数字，那么就肯定不是回文了 如： -121
    if (!(/\d/g.test(x[0]))) {
        return false;
    }
    let i = 0;
    let j = x.length -1;
    while(i < j) {
        if (x[i] !== x[j]) {
            return false;
        }
        i++;
        j--
    }
    return true;
};
```

# 2. [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

1. 题目

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**解法:**

遍历字符串，判断字符是否在滑动窗口数组里

- 不在则 `push` 进数组
- 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 `push` 进数组
- 然后将 `max` 更新为当前最长子串的长度

遍历完，返回 `max` 即可

![img](https://user-gold-cdn.xitu.io/2020/4/25/171af6ebb321bef9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
   let subArr = [];
   let max = 0;
   for( let i = 0; i <  s.length; i++) {
       const index = subArr.indexOf(s[i]);
       if (index >= 0) {
           subArr.splice(0,index +1);
       } 
       subArr.push(s[i]);
       max = Math.max(max, subArr.length);
   }
   return max;
};
```

# 3. [最小栈](https://leetcode-cn.com/problems/min-stack/)

.**题目:**

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。

**示例:**

```javascript
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

**解法：**

```javascript
class MinStack {
    constructor() {
        this.items = [];
        this.min = null;
    }
    push(x) {
        this.items.push(x);
        if (!this.min) {
            this.min = x;
        } else {
            this.min = Math.min(...this.items);
        }
    }

    pop() {
        this.items.pop();
        this.min = Math.min(...this.items);
    }

    top() {
        return this.items[this.items.length -1];
    }
    
    getMin() {
        return  this.min;
    }

}
```

# 6. [验证回文字符串 Ⅱ](https://leetcode-cn.com/problems/valid-palindrome-ii/)

示例 1:

```
输入: "aba"
输出: True
```

示例 2:

```
输入: "abca"
注意:
```

字符串只包含从 a-z 的小写字母。字符串的最大长度是 50000。

**解法**

```
 首尾双指针i,j。

   当i、j指向的元素相等时，同时往前走。知道碰头或者不相等。

   当不相等时，判断去掉i或者去掉j之后的字符串是否为回文串。(因为不相等了， 就只能删除掉其中一个)
```

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var validPalindrome = function(s) {
    function isPalindrome(str) {
        let k = 0;
        let g = str.length - 1;
        while(k < g) {
            if (str[k] !== str[g]) {
                return false;
            } else {
                k++;
                g--;
            }
        }
        return true;
    }


    let i = 0;
    let j = s.length -1;
    while(i < j) {
        if (s[i] !== s[j]) {
            const str1 = s.substring(i, j);
            const str2 = s.substring(i+1, j+1);
            return isPalindrome(str1) || isPalindrome(str2);
        } else {
            i++;
            j--
        }
    }
    return true;
};
```

# 7. [合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。

```javascript
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    // nums1的最大值的下标
    let p1 = m - 1 
    // nums2的最大值下标
    let p2 = n - 1 
    // 要插入的元素的下标
    let p = m + n - 1;

    // 当前两者比较的最大值
    let cur;
    // 要注意数组为空的情况
    while(( p1 >= 0 || p2 >= 0)) {
        if (p1 === -1) {
            cur = nums2[p2--]
        } else if (p2 === -1) {
            cur = nums1[p1--]
        } else if (nums1[p1] < nums2[p2]) {
            cur = nums2[p2--];
        } else {
            cur = nums1[p1--];
        }
        nums1[p--] = cur;
    }
    return nums1;
};
```

# 8. [ 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
     const map = new Map();
     map.set(target - nums[0], 0);
     for(let  i = 1; i < nums.length; i++ ) {
         if (map.has(nums[i])) {
            return [map.get(nums[i]), i];
         } else {
            map.set(target - nums[i], i)
         }
     }
};
```

# hard-- 9. [ 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

![fig1](https://assets.leetcode-cn.com/solution-static/54/54_fig1.png)

```javascript
var spiralOrder = function(matrix) {
  if (matrix.length <= 0 && matrix[0].length <= 0) {
    return;
  }
  // 行数
  let rows = matrix.length;
  // 列数
  let columns = matrix[0].length;

  const order = [];

  let left = 0,
    top = 0,
    right = columns - 1,
    bottom = rows - 1;
  console.log("111");

  while (left <= right && top <= bottom) {
    // 上边变的数据
    for (let colums = left; colums <= right; colums++) {
      order.push(matrix[top][colums]);
    }

    // 左边的数据
    for (let row = top + 1; row <= bottom; row++) {
      order.push(matrix[row][right]);
    }
    if (left < right && top < bottom) {
      // 下边的数据
      for (let columns = right - 1; columns >= left; columns--) {
        order.push(matrix[bottom][columns]);
      }

      // 左边的数据
      for (let row = bottom - 1; row > left; row--) {
        order.push(matrix[row][left]);
      }
    }

    [left, right, top, bottom] = [left + 1, right - 1, top + 1, bottom - 1];
  }

  return order;
};
```

# 10 [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```javascript
var mergeTwoLists = function(l1, l2) {
  if (l1 === null) {
    return l2;
  } else if (l2 === null) {
    return l1;
  } else if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```

# 10 [重排链表](https://leetcode-cn.com/problems/reorder-list/)

示例 1:

给定链表 1->2->3->4, 重新排列为 1->4->2->3.
示例 2:

给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {void} Do not return anything, modify head in-place instead.
 */
var reorderList = function(head) {
  if (!head) return null;
  const arr = [];
  while (head) {
    arr.push(head);
    head = head.next;
  }
  const len = arr.length;
  const middle = Math.floor(arr.length / 2);
  for (let i = 0; i < middle; i++) {
    arr[i].next = arr[len - i - 1];
    arr[len - i - 1].next = arr[i + 1];
  }
  arr[middle].next = null;
};
```

# 11 [ 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
  if (!head) return null;
  let prevNode = null;
  let currentNode = head;
  while (currentNode) {
    const tempNode = currentNode.next;
    currentNode.next = prevNode;
    prevNode = currentNode;
    currentNode = tempNode;
  }
  return prevNode;
};
```

# hard--12. [寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
示例 3：

输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
示例 4：

输入：nums1 = [], nums2 = [1]
输出：1.00000

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```javascript
var findMedianSortedArrays = function(nums1, nums2) {
  const newArr = nums1.concat(nums2);
  newArr.sort((a, b) => a - b);
  const len = newArr.length;
  if (len % 2 === 0) {
    return (newArr[len / 2] + newArr[len / 2 - 1]) / 2;
  } else {
    const temp = Math.floor(len / 2);
    return newArr[temp];
  }
};
console.log(findMedianSortedArrays([1, 3], [2]));
```

# 13. [ 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例 1：

输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let tempNode = new ListNode(0);
    const result = tempNode;
    let carry = 0;
    while(l1 || l2 ||carry) {
        const val1 = l1 ? l1.val : 0;
        const val2 = l2 ? l2.val : 0;
        let sum = val1 + val2 + carry;
        carry = sum >=  10 ? 1 : 0;
        if (l1) {
            l1 = l1.next;
        }
        if (l2) {
            l2 = l2.next;
        }
        const newNode = new ListNode(sum % 10);
        tempNode.next = newNode;
        tempNode = newNode;
    }
    return result.next;
};
```

# hard--14. [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

```javascript
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  // 递归的终止条件
  if (p.length === 0) {
    if (s.length === 0) {
      // 匹配吗模式为空，待匹配的字符串也为空， 那么空匹配空，肯定是 true
      return true;
    } else {
      return false;
    }
  }
  if (s.length !== 0 && (s[0] === p[0] || p[0] === ".")) {
    // 这种情况下， 待匹配字符串和匹配模式的第一个字符是相等
    if (p.length >= 2) {
      if (p[1] === "*") {
        // * 表示*前面的字符串匹配0次或者多次,
        return isMatch(s, p.slice(2)) || isMatch(s.slice(1), p);
      } else {
        return isMatch(s.slice(1), p.slice(1));
      }
    } else {
      return isMatch(s.slice(1), p.slice(1));
    }
  } else {
    // s.length === 0 || (s[0] !== p[0] && p[0] === ".")
    if (p.length >= 2) {
      if (p[1] === "*") {
        // * 表示*前面的字符串匹配0次或者多次,
        return isMatch(s, p.slice(2));
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
};
```

# 15 [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var maxArea = function(height) {
  // 初始 两点之前的距离
  let len = height.length;
  let i = 0,
    j = len - 1;
  let result = 0;
  while (i < j) {
    const arem = Math.min(height[i], height[j]) * (j - i);
    result = Math.max(result, arem);
    if (height[i] <= height[j]) {
      i++;
    } else {
      j--;
    }
  }
  return result;
};
```

# 16. [整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)

```javascript
/**
 * @param {number} num
 * @return {string}
 */
var intToRoman = function(num) {
  const valueModes = [
    [1000, "M"],
    [900, "CM"],
    [500, "D"],
    [400, "CD"],
    [100, "C"],
    [90, "XC"],
    [50, "L"],
    [40, "XL"],
    [10, "X"],
    [9, "IX"],
    [5, "V"],
    [4, "IV"],
    [1, "I"],
  ];
  const result = [];
  for (const [value, mode] of valueModes) {
    while (num >= value) {
      num = num - value;
      result.push(mode);
    }
    if (num == 0) {
      break;
    }
  }

  return result.join("");
};
```

# 17. [罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var romanToInt = function(s) {
    const map = new Map();
    map.set("M", 1000);
    map.set("D", 500);
    map.set("C", 100);
    map.set("L", 50);
    map.set("X", 10);
    map.set("V", 5);
    map.set("I", 1);
    let result = 0;
    for(let i = 0; i < s.length; i++) {
        const curValue = map.get(s[i]);
        const nextValue = map.get(s[i+1])
        // 当前数小于下一个数， 说明得减： IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4
        if (curValue < nextValue) {
            result = result - curValue;
        } else {
            result = result + curValue;
        }
    }
    return result;
};
```

# 18. [最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```javascript
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    // 默认公共前缀为第一个字符串
    let preFix = strs[0];
    for( let i = 1; i < strs.length; i++) {
        // 每一个元素与公共前端对比， 找出新的公共前缀
        preFix = findPreFix(preFix, strs[i]);
    }
    function findPreFix(str1, str2) {
        const result = [];
        let i = 0;
        const n = Math.min(str1.length, str2.length);
        while(i < n) {
            if (str1[i] === str2[i]) {
                result.push(str2[i]);
                i++;
            } else {
                // 不符合就跳出循环
                break;
            }
        }
        return result.join("");
    }

    return preFix === "" ? "" : preFix;
};
```

# 19 [ 三数之和](https://leetcode-cn.com/problems/3sum/)

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {
    // 进行排序
    nums.sort((a, b) => a -b);
    const len = nums.length;
    const mapKey = new Map();
    const result = [];
    for(let i = 0; i <  nums.length; i++) {
         // 最小的数都大于0 ， 再怎么组合也不可能等于0了
        if (nums[i] > 0) {
            break; // 跳出循环
        }
        // 最大的数都小于0， 再怎么组合不可能得到0;
        if (nums[len - 1] < 0) {
            break; // 跳出循环
        }

        //  剩下的两个数使用双指针来找，比 for 循环要快
        let l = i + 1;
        let r = len - 1;
        while( l <  r) {
            // 计算综总和
            const sum = nums[i] + nums[l] + nums[r];
            const key = `${nums[i]} + ${nums[l]} + ${nums[r]}`
            if (sum === 0 && !mapKey.get(key)) {
                result.push([nums[i], nums[l], nums[r]]);
                mapKey.set(key, true);
            }
            if (sum < 0) {
                l++;
            } else {
                r--;
            }
        }
    }
    return result;
};
```

# 20. [最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
    nums.sort((cur, pre) =>  cur - pre);
    const len = nums.length;
    let minSum = null;
    for(let i = 0; i <  len; i++) {
        let l = i + 1;
        let r = len - 1;
        while( l < r) {
            const sum = nums[i] + nums[l] + nums[r];
            //  都相等了最接近的了， 还比较啥
            if (sum ===  target) {
              return target;
            }
            if (minSum === null || Math.abs(target - sum) < Math.abs(target - minSum)) {
                minSum = sum;
            }
            if (sum < target) {
                l++;
            } else {
                r--;
            }

        }
    }
    return minSum;
};
```

# 21.[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```javascript
/**
 * @param {string} digits
 * @return {string[]}
 */
var letterCombinations = function(digits) {
    const mapStr = new Map();
    mapStr.set("2", ["a", "b", "c"]);
    mapStr.set("3", ["d", "e", "f"]);
    mapStr.set("4", ["g", "h", "i"]);
    mapStr.set("5", ["j", "k", "l"]);
    mapStr.set("6", ["m", "n", "o"]);
    mapStr.set("7", ["p", "q", "r", "s"]);
    mapStr.set("8", ["t", "u", "v"]);
    mapStr.set("9", ["w", "x", "y", "z"]);
    if (digits.length == 0) return [];
    const len = digits.length;
    let result = mapStr.get(digits[0]);
    for(let i = 1; i < len; i++) {
        const secondArr = mapStr.get(digits[i]);
        const temp = [];
        for (let j = 0; j <  result.length; j++) {
            let k = 0;
            while (k < secondArr.length) {
                temp.push(`${result[j]}${secondArr[k]}`);
                k++;
            }
        }
        result = temp;
    }
    return result;
};
```

# 22. [四数之和](https://leetcode-cn.com/problems/4sum/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
  nums.sort((a, b) => a - b);
  const len = nums.length;
  const result = [];
  const hasOnlyMap = new Map();
  for (let i = 0; i < len - 3; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {
      // 确第一个数之后， 如果按顺序来，和 > target. 那么剩下就不会有符合条件的了
      break;
    }
    if (nums[i] + nums[len - 3] + nums[len - 2] + nums[len - 1] < target) {
      continue;
    }
    for (let j = i + 1; j < len - 2; j++) {
      if (j > i + 1 && nums[j - 1] === nums[j]) {
        continue;
      }
      if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {
        // 确第一个数之后， 如果按顺序来，和 > target. 那么剩下就不会有符合条件的了
        break;
      }
      if (nums[i] + nums[j] + nums[len - 1] + nums[len - 2] < target) {
        // 确定第二个数之后，如果这个这两个数与后面最大的两个数据加起来都小于 target， 那么双指针循环没有必要了
        continue;
      }
      let l = j + 1,
        r = len - 1;
      while (l < r) {
        const sum = nums[i] + nums[j] + nums[l] + nums[r];
        const key = `${nums[i]}${nums[j]}${nums[l]}${nums[r]}`;
        if (sum === target && !hasOnlyMap.has(key)) {
          result.push([nums[i], nums[j], nums[l], nums[r]]);
          hasOnlyMap.set(key, true);
          while (l < r && nums[l] === nums[l + 1]) {
            l++;
          }
          while (l < r && nums[r] === nums[r - 1]) {
            r--;
          }
        }
        if (sum < target) {
          l++;
        } else {
          r--;
        }
      }
    }
  }
  return result;
};
```

# 23 [ 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @param {number} n
 * @return {ListNode}
 */
var removeNthFromEnd = function(head, n) {
  let first = head;
  let second = head;

  for (let i = 0; i < n; i++) {
    first = first.next;
  }
  if (!first) return head.next;
  while (first) {
    if (!first.next) break;
    first = first.next;
    second = second.next;
  }
  second.next = second.next.next;
  return head;
};
```

# 24. [ 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
  const obj = {
    "[": "]",
    "{": "}",
    "(": ")",
  };
  const arr = [];
  for (let i = 0; i < s.length; i++) {
    if (["[", "(", "{"].includes(s[i])) {
      arr.push(s[i]);
    } else {
      const item = arr.pop();
      if (obj[item] !== s[i]) {
        arr.push(item);
        break;
      }
    }
  }
  return arr.length === 0 ? true : false;
};
```

# 25. [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

[分析](https://leetcode-cn.com/problems/generate-parentheses/solution/yuan-lai-hui-jian-diao-bu-he-fa-de-fen-z-69jt/)

```javascript
var generateParenthesis = function(n) {
  const result = [];
  function dfs(leftNum, rightNum, str) {
    if (str.length === 2 * n) {
      result.push(str);
      return;
    }
    // 某个空位置可以放左括号的条件是，左括号是由余量的，也就是使用的左括号数量 < n，或者说左括号的剩余量 > 0；
    if (leftNum < n) {
      dfs(leftNum + 1, rightNum, str + "(");
    }
    // 某个空位置可以放右括号的条件是，已经使用的左括号的数量大于右括号的数量，或者说右括号的剩余量大于左括号的剩余量；
    if (leftNum > rightNum) {
      dfs(leftNum, rightNum + 1, str + ")");
    }
  }
  dfs(0, 0, "");

  // 当填入一个空位之后， 下一个空位有两种填法： （, ）
  return result;
};
```

# hard--26.[ 合并 K 个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
 */
var mergeKLists = function(lists) {
  if (lists.length === 0) {
    return null;
  }
  const n = lists.length;
  function merge(begin, end) {
    if (begin === end) return lists[begin];
    const mid = Math.floor((begin + end) / 2);
    const l1 = merge(begin, mid);
    const l2 = merge(mid + 1, end);
    return mergeTwoLists(l1, l2);
  }
  return merge(0, n - 1);

  function mergeTwoLists(l1, l2) {
    if (l1 === null) return l2;
    if (l2 === null) return l1;
    if (l1.val < l2.val) {
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
    } else {
      l2.next = mergeTwoLists(l2.next, l1);
      return l2;
    }
  }
};
```

# 27. [两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var swapPairs = function(head) {
  const resultHead = new ListNode(0);
  resultHead.next = head;
  let temp = resultHead;
  while (temp.next !== null && temp.next.next !== null) {
    const node1 = temp.next;
    const node2 = temp.next.next;
    temp.next = node2;
    node1.next = node2.next;
    node2.next = node1;
    temp = node1;
  }
  return resultHead.next;
};
```



# 28. [ 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

[解析](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/)

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    let insertIndex = 1;
    let fast = 1;
    const len = nums.length;
    while(fast <  len) {
        //  不用的元素插入
        if (nums[fast] !== nums[fast-1]) {
            nums[insertIndex] = nums[fast];
            insertIndex++;
        }
        fast++;
    }
    return insertIndex;
};
```

# 29. [移除元素](https://leetcode-cn.com/problems/remove-element/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    const len = nums.length;
    let left = 0;
    for(let right = 0; right <  len; right++) {
        if (nums[right] !== val) {
            nums[left] = nums[right];
            left++;
        }
    }
    return left;
};
```



# 冒泡排序

`思想：`比较相临的两个数，大的数和小的数进行交换位置。

```javascript
{
  // 冒泡算法
  function bubbleSort(arr) {
    const len = arr.length;
    for (let i = len - 1; i > 0; i--) {
      for (let j = 1; j <= i; j++) {
        if (arr[j - 1] > arr[j]) {
          let temp = arr[j - 1];
          arr[j - 1] = arr[j];
          arr[j] = temp;
        }
      }
    }
    return arr;
  }
  console.log(bubbleSort([4, 1, 8, 3, 2, 8, 11, 0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231536252537446.png)

# 快速排序

`思想：` 选定一个数作为基准，小于这个基数放在一个 S 集合， 大于这个基数的放在另外一个 B 集合。这两个集合分别进行快速排序。 最后 S 集合，基数，B 集合进行合并。

```javascript
{
  // 快速排序
  function quickSort(arr) {
    if (arr.length <= 1) {
    } else {
      var leftArr = []; // 比基数小的集合
      var rightArr = []; // 比基数大的集合
      var base = arr[0]; // 基数
      for (let i = 1; i < arr.length; i++) {
        // 注意不能和基数混合 i是从1 开始的
        if (arr[i] < base) {
          leftArr.push(arr[i]);
        } else {
          rightArr.push(arr[i]);
        }
      }
    }
    return quickSort(leftArr).concat(base, quickSort(rightArr));
  }
  console.log(quickSort([4, 1, 8, 3, 2, 9, 11, 0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231537564105629.jpg)

# 归并排序

采用分治的方式，将无序的数组拆分成 N 部分，然后再合并

```javascript
{
  // 递归排序
  function mergeSort(arr) {
    if (arr.length <= 1) {
      return arr;
    } else {
      const mid = Math.ceil(arr.length * 0.5);
      const left = arr.slice(0, mid);
      const right = arr.slice(mid);
      return merge(mergeSort(left), mergeSort(right));
    }
  }
  function merge(left, right) {
    const result = [];
    while (left.length > 0 && right.length > 0) {
      // 注意这里是&&
      if (left[0] < right[0]) {
        result.push(left.shift());
      } else {
        result.push(right.shift());
      }
    }
    return result.concat(left, right);
  }
  console.log(mergeSort([4, 1, 8, 3, 2, 9, 11, 0])); // [0, 1, 2, 3, 4, 8, 9, 11]
}
```

![clipboard.png](https://segmentfault.com/img/bVbc9vd?w=1014&h=855)

# 插入排序

`思想：`在已经排好序的序列上在插入一个数， 这个数与有序序列的数进行比较，放在合适的位置

```javascript
{
  // 插入排序
  function insertSort(a) {
    let len = a.length;
    for (let i = 1; i < len; i++) {
      let key = a[i];
      let j = i - 1;
      while (j >= 0) {
        if (a[j] > key) {
          a[j + 1] = a[j];
        } else {
          break; // 结束循环
        }
        j--;
      }
      a[j + 1] = key;
    }
    return a;
  }
  console.log(insertSort([4, 1, 8, 3, 2, 9, 11, 0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231533515818732.png)

# 选择排序

`思想:`每一次循环都找出最大的数或者最小的数；

```javascript
{
  // 选择排序
  function selectSort(a) {
    const len = a.length;
    for (let i = 0; i < len; i++) {
      let min = a[i];
      let index = i;
      for (let j = i + 1; j < len; j++) {
        // 注意： 是从i+1 开始的
        if (a[j] < min) {
          min = a[j];
          index = j;
        }
      }
      if (index !== i) {
        let temp = a[i];
        a[i] = min;
        a[index] = temp;
      }
    }
    return a;
  }
  console.log(selectSort([4, 1, 8, 3, 2, 9, 11, 0])); // [0, 1, 2, 3, 4, 8, 8, 11]
}
```

![img](https://images0.cnblogs.com/blog2015/687225/201508/231538466606780.jpg)

# 1. jsonp的实现 promise 版本

注意：createElement("script"),  document.body.removeChild

```javascript

function jsonp(url, data) {
  return  new Promise((resolve, reject) => {
    // 回调函数
    const callbackName = "callback";

    let paramsStr = "";
    // 有参数
    if (data) {
      Object.keys(data).forEach((key) => {
        paramsStr = paramsStr + key + "&=" + data[key];
      })
    }
    // 链接拼接
    url = url + "?" + paramsStr + "&callback=" + callbackName;

    // 创建script 标签
    const script = document.createElement("script");
    script.src = url;

    //  回调函数需要绑定在 wiondon 上
    window[callbackName] = function (result) {
      // 触发事件后， 需要删除 script 标签
      document.body.removeChild(script)
      if (result) {
        resolve(result);
      } else {
        reject("没有加载数据")
      }
    }

    // 监听异常
    script.addEventListener("error", (err) => {
      document.body.removeChild(script)
      reject("异常：", err);
    })

    // 添加js节点到document上时，开始请求
    document.body.appendChild(script);
  })

}

jsonp('http://shuliqi.github.io', {a: 1, b: 'heiheihei'})
.then(result => { console.log(result) })
.catch(err => { console.error(err) })

```

# 2. [求数组的所有子集](https://leetcode-cn.com/problems/subsets/)

求数组所有子集 [1,2,3]-->[1] 、[2]、[1,2]、[3]、[1,2,3]、[1,3]、[2,3]

本题有规律可循。

设置初始二维数组：[ [ ] ] 。依次把每个数加入到数组中的每一个元素中，并保留原来的所有元素。

```javascript
例如输入为nums = [1, 2, 3]。

对于数字1，加入到[]中，成为[1]，此时结果数组为[[], [1]]。

对于数字2，加入到[]和[1]中，成为[2],[1,2]，此时结果数组为[[], [1], [2], [1,2]].

对于数字3，加入到[]、[1]、[2]、[1,2]中，成为[3],[1,3],[2,3],[1,2,3]，此时结果数组为
[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]。即为正确输出。
```

```javascript

/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var subsets = function(nums) {
    let result = [[]];
    for (let i = 0; i <  nums.length; i++) {
        // 当前数与之前的集合形成的集合
        const temp = [];
        for (let before of result) {
            temp.push(before.concat(nums[i]))
        }
        result = result.concat(temp)
    }
    return result;
}
```



# 3. 实现 Promise.retry

成功后 resolve 结果，失败后重试，尝试超过一定次数才真正的 reject 比如失败后需要重试三次

```javascript
Promise.retry = (promiseFn, time) => {
  return new Promise(async(resolve, reject) => {
    while(time--) {
      console.log("333", time)
      try {
        console.log("444", `还剩${time}次重试`)
        const result = await promiseFn();
        resolve(result);
        break;
      } catch (error) {
        if (!time) {
          console.log("5555")
          reject(error)
        }
      }
    }
  })
}

const  getData = () => {
  const n  = Math.random();
  return new Promise((resolve, reject) => {
    setTimeout(()=> {
      if (n < 10) {
        reject("获取数据失败");
      } else {
        resolve("获取成功的数据");
      }
    }, 1000)
  })
};
Promise.retry(getData, 3)
.then((result) => {
  console.log("成功", result)
})
.catch((err) => {
  console.log("失败", err)
})
```



#   4. getAllNames 

写个方法 getAllNames 获取所有的 name 值, 返回数组，可以用 递归 和 非递归

```javascript
const data = [
  {
    name: '11',
    children: [
      {
        name: '12',
        children: [
          {
            name: '13'
          }
        ]
      }
    ]
  },
  {
    name: '21',
    children: [
      {
        name: '22',
        children: [
          {
            name: '13',
            shu: [
              { 
                name: "hahaha"
              }
            ]
          }
        ]
      }
    ]
  }    
]
// 写个方法 getAllNames 获取所有的 name 值, 返回数组，可以用 递归 和 非递归

function getAllNames(data) {
  let result = [];
  for (let i = 0; i < data.length; i++) {
    if (Array.isArray(data[i])) {
      result = result.concat(getAllNames(data[i]));
    } else {
      for (let key in data[i]) {
        if (Array.isArray(data[i][key])) {
          result = result.concat(getAllNames(data[i][key]));
        }
        if (key ===  "name") {
          result.push(data[i][key])
        }
      }
    }
  }
  return result;
}
console.log(getAllNames(data));
```

#  5.实现reduce

![image-20210723202059767](/Users/shuliqi/Library/Application Support/typora-user-images/image-20210723202059767.png)

```javascript
const arr = [1,2,3];
Array.prototype.myReduce = function (fn, initValue) {
  for (let i = 0; i < this.length; i++) {
    if (initValue !== 'undefined') {
      initValue = fn(initValue, this[i], i, this);
    } else {
      initValue = fn(this[i], this[i + 1 ], i+1 , this);
    }
  }
  return initValue;
}

/* reduce reduce方法有两个参数
  * 第一个参数：回调函数 --> 每个参数都会调用回调函数
  * 第二个参数： 初始值  --> 如果没有值，那么就是数组的第一个数 
  * 回调函数有四个参数： accumulator-> 累计回调返回值， currentVlaue: 当前值， currentIdex： 当前下标，  最后是原数组
*/

const sum = arr.myReduce((accumulator, currentValue,  currentIndex, array) => {
  return accumulator + currentValue
}, 0);
console.log(sum);
```

**实现map**

![image-20210723202047853](/Users/shuliqi/Library/Application Support/typora-user-images/image-20210723202047853.png)

```javascript
Array.prototype.myMap = function (fn, context) {
  const result = [];
  const self = context || this;
  for (let i = 0; i < self.length; i++) {
    result.push(fn(self[i], i, self));    
  }
  return result;
}
const arr = [1,2,3];
const arr2 = [2,3,4]

const result = arr.myMap((value) => {
  return value + 1;
}, arr2);
console.log(result);

```





# 6. [求数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    // const arr = nums1.length < nums2.length ? nums1: nums2;
    // const result =  arr.filter((value) => nums1.includes(value) && nums2.includes(value));
    // return [...new Set(result)]

    nums1 = new Set(nums1);
    nums2 = new Set(nums2);
    
    function set_intersection(nums1, nums2) {
        if (nums1.size > nums2.size) {
            set_intersection(nums2, nums1);
        }
        const result = new Set();
        for( const value of nums1) {
            if (nums2.has(value)) {
                result.add(value);
            }
        }
        return [...result];
    }
    return set_intersection(nums1, nums2);
};
```

# 7、promise 顺序执行

实现 多个 promise [p1, p2, p3], 并行执行，前一个promise执行完，才能执行下一个promise

```javascript
function fn1() {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(1)
      resolve(1);
    }, 2000)
  })
}

function fn2() {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(2)
      resolve(2);
    }, 3000)
  })
}


async function promise_queue(list) {
  const result = [];
  return new Promise(async(resolve, reject) => {
    let i = 0;
    while(i < list.length) {
      const res = await list[i]();
      result.push(res);
      i++
    }
    resolve(result);
  })
}
promise_queue([fn1, fn2])
.then((data) => {
  console.log("完成", data)
})
```

```javascript
function fn1() {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(1)
      resolve(1);
    }, 2000)
  })
}

function fn2() {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log(2)
      resolve(2);
    }, 3000)
  })
}

function  promise_queue(list) {
  const result = [];
  // 这个需要解释下，遍历数组，每次都把数组包在一个Promise.then()中，相当于list[0]().then(list[1]().then(list[2]().then(...))),
  // 这样内层Promise依赖外层Promise的状态改变，从而实现逐个顺序执行的效果
  return new Promise((resolve, reject) => {
    let p = Promise.resolve();
    list.forEach((promise) => {
      p = p.then(promise).then((data) => {
        result.push(data);
        return result;
      })
    })
    resolve(p);
  })
}
promise_queue([fn1, fn2])
.then((data) => {
  console.log("完成", data)
})
```



# 8. deepKey(obj, fn) 

实现一个方法 deepKey(obj, fn) 转换 obj 的key为大写
  比如

 ```javascript
 const obj = {
    'name': 111,
    'children': [{
      name: 1111
    }],
    eat: ['apple']
  }
 ```

  deepKey(obj, key => key.toLocaleUpperCase())
  转化后为

  ```javascript
{
    'NANME': 111,
    'CHILDREN': [{
      'NAME': 1111
    }],
    'EAT': ['apple']
  }
  ```

解决：

```javascript
  const obj = {
    'name': 111,
    'children': [
      {
        name: 1111
      },
      {
        shu: 2222
      }
    ],
    eat: ['apple']
  }

function deepKey(obj) {

  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) {
      deepKey(obj[i])
    }
  } else if (typeof obj !== "string") {
    for (const key in obj) {
      obj[key.toUpperCase()] = obj[key];
      delete obj[key];
      if (Array.isArray(obj[key.toUpperCase()])) {
        deepKey(obj[key.toUpperCase()])
      }
    }
  }
  return obj;
}
console.log(deepKey(obj))

```

```
{
  NAME: 111,
  CHILDREN: [ { NAME: 1111 }, { SHU: 2222 } ],
  EAT: [ 'apple' ]
}
```



# 9.express中间间实现

```javascript
const http = require("http")
const express = function () {
  const middlewares = [];
  const app = function (req, res) {
    let i = 0;
    const next = function () {
        const fn = middlewares[i++];
        if (!fn) {
          return;
        }
        fn(req, res, next);
    } 
    next();
  }
  app.use = function (middleware) {
    middlewares.push(middleware);
  }

  app.listen = function(...arg) {
    // http.createServer的参数是一个函数， 将req, res 传递进去
    const server=  http.createServer(app);
    server.listen(...arg);
    return server
  }
  return app;
}


var app = express();
app.listen(3000, 'localhost', () => {
  console.log(`开始监听3000端口`)
})

function middleware1(req, res, next) {
  console.log('middleware1 before next()');
  next();
  console.log('middleware1 after next()');
}

function middleware2(req, res, next) {
  console.log('middleware2 before next()');
  next();
  console.log('middleware2 after next()');
}

function middleware3(req, res, next) {
  console.log('middleware3 before next()');
  next();
  console.log('middleware3 after next()');
}

app.use(middleware1);
app.use(middleware2);
app.use(middleware3);

```

[Express 简单实现](https://github.com/zdddrszj/code/blob/master/express/index.js)

# 10. eventEmit 实现

```javascript
class EventEmit {
  constructor () {
    // 用来存放事件监听函数： { event1: [f1, f2]}
    this.listeners = {};
    //  用来设置某个事件能够添加的监听器的最大数量
    this.maxListener = 10;
  }
  // 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。
  on(event, cb) {
    const listeners = this.listeners;
    if (listeners[event] && listeners[event].length >=  this.maxListener) {
      throw consmole.err(`监听器的最大数据是${maxListener}, 您已超出`)
    }
    if (Array.isArray(listeners[event])) {
      listeners[event].push(cb);
    } else {
      listeners[event] = [cb];
    }
  }
  // 按监听器的顺序执行执行每个监听器
  emit(event, ...args) {
    const listeners = this.listeners;
    if ( listeners[event]) {
      listeners[event].forEach((fn) => {
        fn.apply(null, args);
      })
    }
  }
  // 移除指定事件的某个监听回调
  removeListeners(event, listener) {
    if (this.listeners[event]) {
      const index = this.listeners[event].indexOf(listener);
      if (index >= 0) {
        this.listeners[event].splice(index, 1);
      }
    }
  }
  // on类似，但只触发一次，随后便解除事件监听
  once(event, listener) {
    const self = this;
    function fn() {
      listener.apply(null, [...arguments]);
      self.removeListeners(event, fn);
    }
    self.on(event, fn);
  }

  // 移除指定事件的所有监听回调
  removeAllListeners(event) {
    this.listeners[event] = [];
  }

  // 用于提高监听器的默认限制的数量。（默认10监听回调个产生警告）
  setMaxListeners(maxListener) {
    this.maxListener = maxListener;
  }
  // 返回指定事件的监听器数组。
  listeners(event) {
    return this.listeners[event];
  }

}

const eventEmit = new EventEmit();

function f1(...args) {
  console.log("asdas", args)
}
eventEmit.once("even1", f1)
eventEmit.emit("even1", "shuliqi");
eventEmit.emit("even1", "shuliqi")
eventEmit.emit("even1", "shuliqi")
```

# 11 获取 html 所有的标签类型

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <ul>
      <li class="shuliqi">
        asdjask
      </li>
    </ul>
</body>

</html>
<script>
    const map = {};
    function getTagType(node) {
      const tagTypeName = node.nodeName;
      map[tagTypeName] = map[tagTypeName] ? map[tagTypeName] +1 : 1;
      const child = node.childNodes;
      if (child) {
        //  注意循环
        for (let i = 0; i < child.length; i++ ) {
          //  递归调用
          getTagType(child[i]);
        }
      }
    }
    getTagType(document);
    console.log(map);
</script>
```



# 12. 驼峰格式 和 下划线格式转换

## 驼峰下转下划线

```javascript
const data = [
  {
    myName: '11',
    myChildren: [
      {
        myName: '12',
        myChildren: [
          {
            name: '13'
          }
        ]
      }
    ]
  },
  {
    myName: '21',
    myChildren: [
      {
        myName: '22',
        myChildren: [
          {
            myName: '13',
            myShu: [
              { 
                myName: "hahaha"
              }
            ]
          }
        ]
      }
    ]
  }    
]
function jsonToUnderline(data) {
  if (Array.isArray(data)) {
    data.forEach((item) => jsonToUnderline(item));
  } else if (typeof data === 'object') {
    Object.keys(data).forEach((key) => {
      const newKey = key.replace(/[A-Z]/g, (all) => `_${all.toLowerCase()}`);
      data[newKey] = data[key];
      delete data[key];
      jsonToUnderline(data[newKey]);
    })
  }
  return data;
}
console.log(jsonToUnderline(data));
```

 

 ## 下划线转驼峰

```javascript
const data = [
  {
    my_name: '11',
    my_children: [
      {
        my_name: '12',
        my_children: [
          {
            name: '13'
          }
        ]
      }
    ]
  },
  {
    my_name: '21',
    my_children: [
      {
        my_name: '22',
        my_children: [
          {
            my_name: '13',
            my_shu: [
              { 
                my_name: "hahaha"
              }
            ]
          }
        ]
      }
    ]
  }    
]

function undeline(data) {
  if (Array.isArray(data)) {
    data.forEach((item) =>undeline(item));
  } else if (typeof data === "object") {
    Object.keys(data).forEach((key) => {
      const newKey = key.replace(/_(\w)/g, (all, p1) => p1.toUpperCase());
      data[newKey] = data[key];
      delete data[key];
      undeline(data[newKey] )
    })
  }
  return data;
}
console.log(undeline(data))
```

